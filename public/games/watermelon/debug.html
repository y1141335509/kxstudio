<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>æ¸¸æˆè¯Šæ–­</title>
    <style>
        body { background: #222; color: white; font-family: monospace; padding: 20px; }
        .log { background: #333; padding: 10px; margin: 5px 0; border-radius: 5px; }
        .error { background: #500; }
        .success { background: #050; }
        .warning { background: #550; }
        canvas { border: 1px solid #666; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>ğŸ”§ åˆ‡è¥¿ç“œæ¸¸æˆè¯Šæ–­å·¥å…·</h1>
    <div id="logs"></div>
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <script>
        const logs = document.getElementById('logs');
        const canvas = document.getElementById('canvas');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            logs.appendChild(div);
            console.log(message);
            logs.scrollTop = logs.scrollHeight;
        }
        
        async function diagnose() {
            log('ğŸ” å¼€å§‹è¯Šæ–­...', 'info');
            
            // 1. æ£€æŸ¥å¿…è¦æ–‡ä»¶
            const files = ['./index.js', './index.wasm', './index.pck'];
            for (const file of files) {
                try {
                    log(`æ£€æŸ¥æ–‡ä»¶: ${file}`, 'info');
                    const response = await fetch(file, { method: 'HEAD' });
                    if (response.ok) {
                        const size = response.headers.get('content-length');
                        log(`âœ… ${file} å­˜åœ¨ (å¤§å°: ${size ? (size/1024/1024).toFixed(2) + 'MB' : 'æœªçŸ¥'})`, 'success');
                    } else {
                        log(`âŒ ${file} ä¸å­˜åœ¨ (çŠ¶æ€: ${response.status})`, 'error');
                        return;
                    }
                } catch (error) {
                    log(`âŒ æ— æ³•è®¿é—® ${file}: ${error.message}`, 'error');
                    return;
                }
            }
            
            // 2. æ£€æŸ¥WebGLæ”¯æŒ
            log('æ£€æŸ¥WebGLæ”¯æŒ...', 'info');
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            if (gl) {
                log('âœ… WebGLæ”¯æŒæ­£å¸¸', 'success');
                log(`WebGLç‰ˆæœ¬: ${gl.getParameter(gl.VERSION)}`, 'info');
                log(`æ¸²æŸ“å™¨: ${gl.getParameter(gl.RENDERER)}`, 'info');
            } else {
                log('âŒ WebGLä¸æ”¯æŒ', 'error');
                return;
            }
            
            // 3. æ£€æŸ¥Godotå¼•æ“åŠ è½½
            log('åŠ è½½Godotå¼•æ“...', 'info');
            try {
                // åŠ¨æ€åŠ è½½index.js
                const script = document.createElement('script');
                script.src = './index.js';
                script.onload = () => {
                    log('âœ… Godotå¼•æ“è„šæœ¬åŠ è½½æˆåŠŸ', 'success');
                    testEngine();
                };
                script.onerror = (error) => {
                    log('âŒ Godotå¼•æ“è„šæœ¬åŠ è½½å¤±è´¥', 'error');
                    log(`é”™è¯¯è¯¦æƒ…: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                };
                document.head.appendChild(script);
            } catch (error) {
                log(`âŒ å¼•æ“åŠ è½½å¼‚å¸¸: ${error.message}`, 'error');
            }
        }
        
        function testEngine() {
            log('æµ‹è¯•Godotå¼•æ“...', 'info');
            
            try {
                if (typeof Engine === 'undefined') {
                    log('âŒ Engineç±»æœªå®šä¹‰', 'error');
                    return;
                }
                
                log('âœ… Engineç±»å¯ç”¨', 'success');
                
                // æ£€æŸ¥å¿…è¦çš„æ–¹æ³•
                const methods = ['getMissingFeatures', 'load', 'unload'];
                methods.forEach(method => {
                    if (typeof Engine[method] === 'function') {
                        log(`âœ… Engine.${method} å¯ç”¨`, 'success');
                    } else {
                        log(`âŒ Engine.${method} ä¸å¯ç”¨`, 'error');
                    }
                });
                
                // æ£€æŸ¥ç¼ºå¤±çš„åŠŸèƒ½
                const missing = Engine.getMissingFeatures();
                if (missing.length === 0) {
                    log('âœ… æ‰€æœ‰å¿…éœ€åŠŸèƒ½éƒ½å¯ç”¨', 'success');
                } else {
                    log(`âš ï¸ ç¼ºå¤±åŠŸèƒ½: ${missing.join(', ')}`, 'warning');
                }
                
                // å°è¯•åˆ›å»ºå¼•æ“å®ä¾‹
                log('åˆ›å»ºå¼•æ“å®ä¾‹...', 'info');
                const engine = new Engine({
                    canvas: canvas,
                    executable: 'index',
                    threads: false,
                    canvasResizePolicy: 0
                });
                
                log('âœ… å¼•æ“å®ä¾‹åˆ›å»ºæˆåŠŸ', 'success');
                
                // å°è¯•å¯åŠ¨æ¸¸æˆ
                log('å°è¯•å¯åŠ¨æ¸¸æˆ...', 'info');
                engine.startGame({
                    onProgress: function(current, total) {
                        log(`åŠ è½½è¿›åº¦: ${current}/${total} (${((current/total)*100).toFixed(1)}%)`, 'info');
                    }
                }).then(() => {
                    log('ğŸ‰ æ¸¸æˆå¯åŠ¨æˆåŠŸï¼', 'success');
                }).catch(error => {
                    log(`âŒ æ¸¸æˆå¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
                    log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'error');
                });
                
            } catch (error) {
                log(`âŒ å¼•æ“æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'error');
            }
        }
        
        // å¼€å§‹è¯Šæ–­
        diagnose();
    </script>
</body>
</html>